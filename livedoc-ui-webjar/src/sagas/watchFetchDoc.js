// @flow
import { push } from 'react-router-redux';
import type { SagaIterator } from 'redux-saga';
import { all, apply, call, put, takeLatest } from 'redux-saga/effects';
import { APP_SPEC_VERSION, APP_VERSION } from '../App';
import type { Livedoc } from '../model/livedoc';
import type { FetchDocAction, LoadDocFromFileAction, ReloadDocAction } from '../redux/actions/loader';
import { actions, FETCH_DOC, LOAD_DOC_FROM_FILE, RELOAD_DOC } from '../redux/actions/loader';

export function* watchFetchDoc(): SagaIterator {
  yield all([
    takeLatest(FETCH_DOC, fetchDoc),
    takeLatest(LOAD_DOC_FROM_FILE, loadDocFromFile),
    takeLatest(RELOAD_DOC, reloadDoc)
  ]);
}

const fetchOptions = {
  headers: {
    'Accept': 'application/livedoc+json',
  },
  mode: 'cors',
  credentials: 'include',
};

function* loadDocFromFile(action: LoadDocFromFileAction): SagaIterator {
  try {
    console.log(`Reading documentation from ${action.file.name}`);
    const json: string = yield call(readFileAsText, action.file);
    const data = JSON.parse(json);
    const livedoc = ensureValidPayload(data);
    yield put(actions.loadFromFileSuccess(livedoc, action.file));
    yield put(push('/global'));
  } catch (error) {
    yield* handleError('Error reading doc from file: ' + error);
  }
}

const readFileAsText = (inputFile) => {
  const fileReader = new FileReader();

  return new Promise((resolve, reject) => {
    fileReader.onerror = () => {
      fileReader.abort();
      reject(fileReader.error);
    };
    fileReader.onload = () => {
      resolve(fileReader.result);
    };
    fileReader.readAsText(inputFile);
  });
};

function* fetchDoc(action: FetchDocAction): SagaIterator {
  try {
    console.log('Fetching documentation at', action.url);
    const response: Response = yield call(fetch, action.url, fetchOptions);
    yield* updateDocAndNavigateHome(response, action);
  } catch (error) {
    yield* handleError('Could not fetch documentation. Potential causes: a malformed URL, network issue, or a' +
            ' cross-origin request that is not allowed by the server. Please open the console for details.');
  }
}

function* reloadDoc(action: ReloadDocAction): SagaIterator {
  try {
    console.log('Reloading documentation from', action.url);
    const response: Response = yield call(fetch, action.url, fetchOptions);
    yield* updateDocWithResponse(response, action.url);
  } catch (error) {
    console.warn('Could not reload doc, keeping offline doc. Error:', error.message);
  }
}

function* updateDocAndNavigateHome(response: Response, action: FetchDocAction): SagaIterator {
  try {
    yield* updateDocWithResponse(response, action.url);
    yield put(push('/global'));
  } catch (error) {
    yield* handleError(error.message);
  }
}

function* updateDocWithResponse(response: Response, url: string): SagaIterator {
  if (!response.ok) {
    throw new Error(`Could not fetch documentation: HTTP ${response.status} ${response.statusText}`);
  }
  const data: Livedoc = yield apply(response, response.json);
  console.log('Fetched documentation:', data);
  const livedoc = ensureValidPayload(data);
  yield put(actions.fetchSuccess(livedoc, url));
}

function ensureValidPayload(data: ?Livedoc): Livedoc {
  if (!data) {
    throw new Error('Unable to read documentation: no response payload');
  }
  if (data.error) {
    throw new Error(`Server returned the following error: ${data.error}`);
  }
  checkVersion(data);
  return data;
}

function checkVersion(data) {
  let metaData = data.livedocInfo;
  if (!metaData || !metaData.version) {
    throw new Error('Cannot read version info from payload, it was probably generated by an old version of Livedoc');
  }
  const dataVersion = metaData.version;
  if (APP_SPEC_VERSION === 5 && (dataVersion === '5.0.0' && dataVersion === '5.0.1')) {
    return; // these versions are compatible with spec v5, despite the absence of specVersion
  }
  const specVersion = metaData.specVersion;
  if (!specVersion) {
    checkSoftwareVersionMatch(dataVersion);
  } else if (specVersion !== APP_SPEC_VERSION) {
    throw new Error(`The fetched Livedoc is a JSON spec v${specVersion} generated by Livedoc v${dataVersion}, it ` +
            `cannot be displayed in UI v${APP_VERSION}, which expects a JSON specification v${APP_SPEC_VERSION}`);
  }
}

function checkSoftwareVersionMatch(dataVersion) {
  if (dataVersion !== APP_VERSION) {
    throw new Error(
            `The fetched data was generated by Livedoc v${dataVersion}, it cannot be displayed in UI v${APP_VERSION}`);
  }
}

function* handleError(errorDetail: string): SagaIterator {
  yield put(actions.fetchError(errorDetail));
}
