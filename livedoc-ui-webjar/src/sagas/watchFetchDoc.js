// @flow
import { push } from 'react-router-redux';
import type { SagaIterator } from 'redux-saga';
import { apply, call, put, takeLatest } from 'redux-saga/effects';
import { APP_VERSION } from '../App';
import type { Livedoc } from '../model/livedoc';
import type { FetchDocAction } from '../redux/actions/loader';
import { actions, FETCH_DOC } from '../redux/actions/loader';

export function* watchFetchDoc(): SagaIterator {
  console.log('Watching for FETCH_DOC actions');
  yield takeLatest(FETCH_DOC, fetchDoc);
}

const fetchOptions = {
  headers: {
    'Accept': 'application/livedoc+json'
  },
  mode: 'cors',
  credentials: 'include',
};

function* fetchDoc(action: FetchDocAction): SagaIterator {
  try {
    console.log('Fetching documentation at', action.url);
    const response: Response = yield call(fetch, action.url, fetchOptions);
    yield* handleResponse(response);
  } catch (error) {
    yield* handleError('Could not fetch documentation. Potential causes: a malformed URL, network issue, or a' +
            ' CORS request that is not allowed by the server. Please open the console for details.');
  }
}

function* handleResponse(response: Response): SagaIterator {
  if (!response.ok) {
    yield* handleError(`Could not fetch documentation: HTTP ${response.status} ${response.statusText}`);
    return;
  }
  const data: Livedoc = yield apply(response, response.json);
  console.log('Fetched documentation:', data);
  yield* handleResponsePayload(data);
}

function* handleResponsePayload(data: ?Livedoc): SagaIterator {
  if (!data) {
    yield* handleError('Unable to read documentation: no response payload');
    return;
  }
  let metaData = data.livedocInfo;
  if (!metaData || !metaData.version) {
    yield* handleError('Cannot read version info from payload, it was probably generated by an old version of Livedoc');
    return;
  }
  const dataVersion = metaData.version;
  if (dataVersion !== APP_VERSION) {
    const msg = `The fetched data was generated by Livedoc v${dataVersion}, it cannot be displayed in UI v${APP_VERSION}`;
    yield* handleError(msg);
  } else {
    yield put(actions.updateDoc(data));
    yield put(push('/global'));
  }
}

function* handleError(errorDetail: string): SagaIterator {
  yield put(actions.fetchError(errorDetail));
}
